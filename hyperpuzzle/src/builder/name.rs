use std::fmt;

use itertools::Itertools;

/// Set of names.
#[derive(Debug, Clone, Hash)]
pub struct NameSet(AstNode);
impl NameSet {
    /// Set of names containing only the empty string.
    pub const EMPTY_STRING: Self = Self(AstNode::Seq(vec![]));

    /// Returns the first name in the set of all possible names. Returns `None`
    /// if there are no names.
    pub fn canonical_name(&self) -> Option<String> {
        self.0.gen_first()
    }

    /// Returns the size of the set of all possible names.
    pub fn name_set_len(&self) -> Option<usize> {
        self.0.generated_set_len()
    }

    /// Retursn a list of all the strings generated by the grammar. If the
    /// number of strings exceeds [`crate::MAX_NAME_SET_SIZE`], then an error is
    /// returned instead.
    pub fn string_set(&self) -> Result<Vec<String>, TooManyNames> {
        self.string_set_with_limit(Some(crate::MAX_NAME_SET_SIZE))
    }
    /// Returns a list of all the strings generated by the grammar. If the
    /// number of strings exceeds `limit`, then an error is returned instead.
    pub fn string_set_with_limit(&self, limit: Option<usize>) -> Result<Vec<String>, TooManyNames> {
        if let Some(limit) = limit {
            let len = self.name_set_len();
            if len.is_none_or(|len| len > limit) {
                return Err(TooManyNames {
                    canonical: self.canonical_name().expect("no name"),
                    len,
                    limit,
                });
            }
        }

        Ok(self.0.generated_set())
    }

    /// Combines names in an ordered sequence.
    pub fn new_seq(strings: impl IntoIterator<Item = impl Into<Self>>) -> Self {
        Self(AstNode::seq_of(strings.into_iter().map(|s| s.into().0)))
    }
    /// Combines names in an unordered sequence.
    pub fn new_set(strings: impl IntoIterator<Item = impl Into<Self>>) -> Self {
        Self(AstNode::set_of(strings.into_iter().map(|s| s.into().0)))
    }
    /// Combines names by selecting any one of them.
    pub fn any(choices: impl IntoIterator<Item = impl Into<Self>>) -> Self {
        Self(AstNode::any_of(choices.into_iter().map(|s| s.into().0)))
    }

    /// Returns `true` if the set of names is empty or contains only the empty
    /// string.
    pub fn is_empty_string_or_never(&self) -> bool {
        self.0.is_empty_string() || self.0.is_never()
    }
}
impl<T: Into<AstNode>> From<T> for NameSet {
    fn from(value: T) -> Self {
        NameSet(value.into())
    }
}

/// Error indicating that a name set is too big.
#[derive(Debug, Clone)]
#[allow(missing_docs)]
pub struct TooManyNames {
    /// Canonical name.
    pub canonical: String,
    /// Size of the name set (or `None` if it is larger than `usize::MAX`).
    pub len: Option<usize>,
    /// Maximum number of names allowed.
    pub limit: usize,
}
impl std::error::Error for TooManyNames {}
impl fmt::Display for TooManyNames {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "name set for {:?}", self.canonical)?;
        match self.len {
            Some(len) => write!(f, "size {len} is too big")?,
            None => write!(f, "is way too big")?,
        }
        write!(f, "(maximum is {})", self.limit)?;
        Ok(())
    }
}

/// Node in a name grammar.
#[derive(Debug, Clone, Hash)]
enum AstNode {
    /// Never matches.
    Never,
    /// Literal string that must match exactly. May be the empty string.
    Literal(String), // TODO: smolstr or similar
    /// Choice. Exactly one component must be present in the string to match.
    Any(Vec<AstNode>),
    /// Ordered sequence. All components must be present in the string (in
    /// order) to match.
    Seq(Vec<AstNode>),
    /// Unordered set. All components must be present in the string (in any order) to
    /// match.
    Set(Vec<AstNode>),
}
impl<T: Clone + Into<AstNode>> From<&T> for AstNode {
    fn from(value: &T) -> Self {
        value.clone().into()
    }
}
impl From<String> for AstNode {
    fn from(value: String) -> Self {
        AstNode::Literal(value)
    }
}
impl From<&str> for AstNode {
    fn from(value: &str) -> Self {
        AstNode::Literal(value.to_string())
    }
}
impl From<char> for AstNode {
    fn from(value: char) -> Self {
        AstNode::Literal(value.to_string())
    }
}
impl From<&NameSet> for AstNode {
    fn from(value: &NameSet) -> Self {
        value.0.clone()
    }
}
impl AstNode {
    /// Returns `true` if the set of strings generated by the grammar is empty.
    fn is_never(&self) -> bool {
        match self {
            AstNode::Never => true,
            AstNode::Literal(_) => false,
            AstNode::Any(vec) => vec.iter().all(|node| node.is_empty_string()),
            AstNode::Seq(vec) | AstNode::Set(vec) => vec.iter().any(|node| node.is_empty_string()),
        }
    }
    /// Returns `true` if the set of strings generated by the grammar is exactly
    /// the set containing only the empty string (`{""}`).
    fn is_empty_string(&self) -> bool {
        match self {
            AstNode::Never => false,
            AstNode::Literal(s) => s.is_empty(),
            AstNode::Any(vec) => vec
                .iter()
                .all(|node| node.is_never() || node.is_empty_string()),
            AstNode::Seq(vec) | AstNode::Set(vec) => vec.iter().all(|node| node.is_empty_string()),
        }
    }

    /// Returns the first string generated from the grammar. Returns `None` if
    /// `self.is_never()`.
    fn gen_first(&self) -> Option<String> {
        match self {
            AstNode::Never => None,
            AstNode::Literal(s) => Some(s.to_string()),
            AstNode::Any(vec) => vec.first().and_then(|node| node.gen_first()),
            AstNode::Seq(vec) | AstNode::Set(vec) => {
                let mut ret = String::new();
                for node in vec {
                    ret += &node.gen_first()?;
                }
                Some(ret)
            }
        }
    }

    /// Returns the number of distinct strings generated by the grammar. Returns
    /// `None` in the case of integer overflow.
    fn generated_set_len(&self) -> Option<usize> {
        match self {
            AstNode::Never => Some(0),
            AstNode::Literal(_) => Some(1),
            AstNode::Any(vec) => checked_sum(vec.iter().map(|node| node.generated_set_len())),
            AstNode::Seq(vec) => checked_product(vec.iter().map(|node| node.generated_set_len())),
            AstNode::Set(vec) => usize::checked_mul(
                checked_product(vec.iter().map(|node| node.generated_set_len()))?,
                checked_factorial(vec.len())?,
            ),
        }
    }

    /// Returns a list of all possible strings generated by the grammar.
    ///
    /// **WARNING: This set may be grow superexponentially (factorial) with
    /// respect to the grammar size.**
    fn generated_set(&self) -> Vec<String> {
        match self {
            AstNode::Never => vec![],
            AstNode::Literal(s) => vec![s.clone()],
            AstNode::Any(vec) => vec.iter().flat_map(|node| node.generated_set()).collect(),
            AstNode::Seq(vec) => vec
                .iter()
                .map(|node| node.generated_set())
                .multi_cartesian_product()
                .map(|strings| strings.join(""))
                .collect(),
            AstNode::Set(vec) => vec
                .iter()
                .map(|node| node.generated_set())
                .permutations(vec.len())
                .flat_map(|permutation| {
                    permutation
                        .into_iter()
                        .multi_cartesian_product()
                        .map(|strings| strings.join(""))
                })
                .collect(),
        }
    }

    fn concat(&self, other: &Self) -> Self {
        AstNode::Seq(match (self, other) {
            (AstNode::Never, _) | (_, AstNode::Never) => return AstNode::Never,
            (AstNode::Seq(a), AstNode::Seq(b)) => itertools::chain(a, b).cloned().collect(),
            (a, AstNode::Seq(b)) => itertools::chain(std::iter::once(a), b).cloned().collect(),
            (AstNode::Seq(a), b) => itertools::chain(a, std::iter::once(b)).cloned().collect(),
            (a, b) => vec![a.clone(), b.clone()],
        })
    }

    fn any_of(options: impl IntoIterator<Item = impl Into<Self>>) -> Self {
        let mut ret = vec![];
        for option in options {
            match option.into() {
                AstNode::Any(vec) => ret.extend(vec),
                other => ret.push(other),
            }
        }
        match vec_to_zero_or_one_elem(ret) {
            Ok(None) => AstNode::Never,
            Ok(Some(one_choice)) => one_choice,
            Err(choices) => AstNode::Any(choices),
        }
    }

    fn seq_of(options: impl IntoIterator<Item = impl Into<Self>>) -> Self {
        let mut ret = vec![];
        for option in options {
            match option.into() {
                AstNode::Seq(vec) => ret.extend(vec),
                other => ret.push(other),
            }
        }
        match vec_to_zero_or_one_elem(ret) {
            Ok(None) => AstNode::Literal(String::new()),
            Ok(Some(one_choice)) => one_choice,
            Err(choices) => AstNode::Seq(choices),
        }
    }

    fn set_of(options: impl IntoIterator<Item = impl Into<Self>>) -> Self {
        // We can flatten "any" and "seq," but not "set"!
        let ret = options.into_iter().map(|node| node.into()).collect_vec();
        match vec_to_zero_or_one_elem(ret) {
            Ok(None) => AstNode::Literal(String::new()),
            Ok(Some(one_choice)) => one_choice,
            Err(choices) => AstNode::Set(choices),
        }
    }
}

fn checked_factorial(n: usize) -> Option<usize> {
    checked_product((2..=n).map(Some))
}

fn checked_product(iter: impl IntoIterator<Item = Option<usize>>) -> Option<usize> {
    let mut product = 1_usize;
    for it in iter {
        product = product.checked_mul(it?)?;
    }
    Some(product)
}

fn checked_sum(iter: impl IntoIterator<Item = Option<usize>>) -> Option<usize> {
    let mut sum = 0_usize;
    for it in iter {
        sum = sum.checked_add(it?)?;
    }
    Some(sum)
}

fn vec_to_zero_or_one_elem<T>(vec: Vec<T>) -> Result<Option<T>, Vec<T>> {
    if vec.len() == 1 {
        Ok(vec.into_iter().next())
    } else {
        Err(vec)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_name() {
        assert_eq!(NameSet::EMPTY_STRING.name_set_len(), Some(1));
        assert_eq!(NameSet::EMPTY_STRING.string_set().unwrap(), vec![""]);
        assert_eq!(NameSet::EMPTY_STRING.canonical_name().unwrap(), "");

        let test_cases: &[(AstNode, &[&str])] = &[
            (AstNode::any_of(['a', 'b', 'c']), &["a", "b", "c"]),
            (AstNode::seq_of(['a', 'b', 'c']), &["abc"]),
            (
                AstNode::set_of(['a', 'b', 'c']),
                &["abc", "acb", "bac", "bca", "cab", "cba"],
            ),
            (
                AstNode::seq_of([AstNode::set_of(['a', 'b']), AstNode::set_of(['c', 'd'])]),
                &["abcd", "abdc", "bacd", "badc"],
            ),
            (
                AstNode::set_of([AstNode::seq_of(['a', 'b']), AstNode::any_of(['c', 'd'])]),
                &["abc", "abd", "cab", "dab"],
            ),
            (
                AstNode::set_of([AstNode::set_of(['a', 'b']), AstNode::set_of(['c', 'd'])]),
                &[
                    "abcd", "abdc", "bacd", "badc", "cdab", "cdba", "dcab", "dcba",
                ],
            ),
        ];
        for (grammar, expected_set) in test_cases {
            println!("testing {grammar:?} = {expected_set:?}");
            assert_eq!(grammar.generated_set_len(), Some(expected_set.len()));
            assert_eq!(grammar.generated_set(), *expected_set);
            assert_eq!(
                grammar.gen_first().as_deref(),
                expected_set.first().copied(),
            );
        }
    }
}
