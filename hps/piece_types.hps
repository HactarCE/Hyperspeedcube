use * from euclid

// Parameter conventions:
// - `layers` is the number of shallow-cut subdivions. It is 1 for a 2x2x2 or
//   3x3x3 Rubik's cube, 2 for a 4x4x4 or 5x5x5, etc.
// - `X_adj` is a region that contains all overlap between `X` and other grips.
//   For example, `UF_adj` must contain all pieces in `U'*' | F'*'` that have grips other
//   than `U` or `F`. It may contain any pieces outside of `U'*' | F'*'`.
//
// These functions do not call `unify_piece_types()`, so you'll still have to do
// that in the puzzle definition.

export fn mark_everything_core() {
    mark_piece(REGION_ALL, "core", "Core")
}

// Returns the string "Inner" if `i < threshold`, "Outer" if `i > threshold`, or
// "Middle" if `i == threshold`.
export fn inner_outer_prefix(i, threshold) {
    if i < threshold { return "Inner" }
    if i > threshold { return "Outer" }
    if i == threshold { return "Middle" }
}

export fn mark_left_right(region, base_name, base_display, i, j) {
    if i < j {
        sentencecased = base_display.capital()
        add_piece_type("${base_name}/${i}_${j}", "${sentencecased} (${i}, ${j})")
        add_piece_type("${base_name}/${i}_${j}/left", "Left ${base_display} (${i}, ${j})")
        mark_piece(region, "${base_name}/${i}_${j}/right", "Right ${base_display} (${i}, ${j})")
    } else {
        mark_piece(region, "${base_name}/${j}_${i}/left", "Left ${base_display} (${j}, ${i})")
    }
}
