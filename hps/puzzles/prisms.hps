use * from euclid

param_polygon_size = @shapes/i/polygon.param_size
fn param_polygon_width(name) { #{ name = name, type = Int, default = 3, min = 1, max = 10 } }
fn param_line_height(name) { #{ name = name, type = Int, default = 3, min = 1, max = 10 } }

export fn ft_prism_name(n: Nat, width: Nat, height: Nat, cut_type: Str) -> Str {
    "Face-Turning ${@shapes/prisms/polygonal_prism.name(n)} (${cut_type} ${width}x${height})"
}
export fn duoprism_name(n: Nat, m: Nat) -> Str { "${n}x${m} Duoprism" }
export fn ft_duoprism_name(n: Nat, m: Nat, n_size: Nat, m_size: Nat, cut_type: Str) -> Str {
    "Facet-Turning ${duoprism_name(n, m)} (${cut_type} ${n_size}x${m_size})"
}
export fn ft_duoprism_name(n: Nat, m: Nat, n_size: Nat, m_size: Nat, n_cut_type: Str?, m_cut_type: Str?) -> Str {
    if n_cut_type == m_cut_type {
        ft_duoprism_name(n, m, n_size, m_size, n_cut_type)
    } else {
        "Facet-Turning ${duoprism_name(n, m)} ${n_cut_type} ${n_size} x ${m_cut_type} ${m_size}"
    }
}

// Face-Turning Polygonal Prism (Shallow) generator
add_puzzle_generator(
    id = "ft_polygonal_prism",
    version = "0.1.0",
    name = "Face-Turning Polygonal Prism (Shallow)",
    params = [
        param_polygon_size("Polygon size"),
        param_polygon_width("Width"),
        param_line_height("Height"),
    ],
    engine = "euclid",
    gen = fn(n, width, height) {
        return #{
            name = ft_prism_name(n, width, height, "Shallow"),
            ndim = 3,
            colors = "polygonal_prism:${n}",
            twists = "ft_polygonal_prismic:${n}",
            build = fn() {
                use sym, polygon, line from @shapes/product(#{
                    polygon = @shapes/i/polygon.new(n),
                    line = @shapes/line.new(),
                })
                h = polygon.edge_length / 2

                with #sym = sym {
                    // Carve shape
                    carve(plane(line.endpoint * h), line.names("U", "D"))
                    carve(plane(polygon.edge_pole), "F${polygon.edge_names}")

                    // Slice layers
                    add_layers(#twists.base_axis, @util/layers.inclusive(h, -h, height))
                    add_layers(#twists.side_axis, polygon.shallow_cut_depths(width))
                }
            },

            tags = #{
                type = "puzzle",
                completeness = #{
                    laminated = n <= 2, // TODO
                    real = n <= 3, // TODO
                    super = n <= 2, // TODO
                },
                "cuts/depth/deep/to_adjacent" = n.is_even(), // TODO
                "cuts/depth/half" = n.is_even(), // TODO
                "external/leaderboard" = n >= 2, // TODO
                "pieces/standard" = true,
            },
        }
    },

    tags = #{
        schema = 1,
        author = ["Andrew Farkas", "Milo Jacquet"],
        shape = "3d/prism",
        axes = "3d/prism",
        turns_by = ["facet", "face"],
        algebraic = ["doctrinaire", "pseudo/doctrinaire"],
        cuts = "depth/shallow", // TODO
    },
)

// Face-Turning Polygonal Prism twist system generator
add_twist_system_generator(
    id = "ft_polygonal_prismic",
    name = "Face-Turning Polygonal Prism",
    params = [param_polygon_size("Polygon Size")],
    engine = "euclid",
    ndim = 3,
    gen = fn(n) {
        return #{
            name = "Face-Turning ${@shapes/prisms/polygonal_prism.name(n)}",
            build = fn() {
                shape = @shapes/prisms/polygonal_prism.new(n)

                // Add axes and twists
                with #sym = shape.sym {
                    export base_axis = add_axis(shape.base_pole, shape.base_names)
                    export side_axis = add_axis(shape.side_pole, shape.side_names)
                    add_twist(base_axis, #sym.thru([1, 0]), gizmo_pole_distance = shape.h)
                    add_twist(side_axis, #sym.thru([2, 0]), gizmo_pole_distance = 1)
                }

                // Add global twist directions
                fn cw(axis) { #twists[axis.name] }
                fn ccw(axis) { #twists[axis.name].rev() }
                add_twist_direction("CW", fn(ax) { [cw(ax)] })
                add_twist_direction("CCW", fn(ax) { [ccw(ax)] })

                // Add vantage group
                add_vantage_group(
                    id = "polygonal_prism",
                    symmetry = shape.sym,
                    refs = [
                        [shape.base_pole, shape.base_names],
                        [shape.side_pole, shape.side_names],
                    ],
                    init = ["FA", "U"],
                )

                // Add side-centered vantage set
                F = side_axis
                U = base_axis
                y = shape.sym.thru([2, 0])
                z2 = shape.sym.thru([1, 0])
                add_vantage_set(
                    name = "Side-centered",
                    group = "polygonal_prism",
                    view_offset = rot(start = vec(x=1), end = vec(z=1), angle = 20°)
                                * rot(start = vec(y=1), end = vec(z=1), angle = 35°),
                    transforms = #{
                        y = y, "y'" = y.rev(),
                        z2 = z2, "z2'" = z2.rev(),
                    },
                    axes = #{
                        F = F,
                        R = #twists.U.transform(F),
                        L = #twists.U.rev().transform(F),
                        U = U,
                        D = #twists.FA.transform(U),
                    },
                )
            },
        }
    }
)
