use * from euclid

export FACET_GIZMO_EDGE_FACTOR = 2/3
export RIDGE_GIZMO_FACTOR = 1/2

param_polygon_size = @shapes/i/polygon.param_size
fn param_polygon_width(name) { #{ name = name, type = Int, default = 3, min = 1, max = 10 } }
fn param_line_height(name) { #{ name = name, type = Int, default = 3, min = 1, max = 10 } }

fn n_by_m_if_not_3(width: Nat, height: Nat) -> Str {
    if width == 3 and height == 3 { "" } else { " ${width}x${height}" }
}

export fn ft_polygonal_prism_name(n: Nat, width: Nat, height: Nat, cut_type: Str) -> Str {
    "FT ${@shapes/prisms/polygonal_prism.name(n)} (${cut_type}${n_by_m_if_not_3(width, height)})"
}
export fn ft_polygonal_prism_long_name(n: Nat, width: Nat, height: Nat, cut_type: Str) -> Str {
    "Facet-Turning ${@shapes/prisms/polygonal_prism.name(n)} (${cut_type} ${width}x${height})"
}
export fn ft_duoprism_name(n: Nat, m: Nat, n_layers: Nat, m_layers: Nat, cut_type: Str) -> Str {
    "FT ${@shapes/prisms/polygonal_duoprism.name(n, m)} (${cut_type}${n_by_m_if_not_3(n_layers, m_layers)})"
}
export fn ft_duoprism_name(n: Nat, m: Nat, n_layers: Nat, m_layers: Nat, n_cut_type: Str?, m_cut_type: Str?) -> Str {
    if n_cut_type == m_cut_type {
        ft_duoprism_name(n, m, n_layers, m_layers, n_cut_type)
    } else if n_layers == 3 and m_layers == 3 {
        "FT ${@shapes/prisms/polygonal_duoprism.name(n, m)} (${n_cut_type} x ${m_cut_type})"
    } else {
        "FT ${@shapes/prisms/polygonal_duoprism.name(n, m)} (${n_cut_type} ${n_layers} x ${m_cut_type} ${m_layers})"
    }
}
export fn ft_duoprism_long_name(n: Nat, m: Nat, n_layers: Nat, m_layers: Nat, cut_type: Str) -> Str {
    "Facet-Turning ${@shapes/prisms/polygonal_duoprism.long_name(n, m)} (${cut_type} ${n_layers}x${m_layers})"
}
export fn ft_duoprism_long_name(n: Nat, m: Nat, n_layers: Nat, m_layers: Nat, n_cut_type: Str?, m_cut_type: Str?) -> Str {
    if n_cut_type == m_cut_type {
        ft_duoprism_long_name(n, m, n_layers, m_layers, n_cut_type)
    } else {
        "Facet-Turning ${@shapes/prisms/polygonal_duoprism.long_name(n, m)} (${n_cut_type} ${n_layers} x ${m_cut_type} ${m_layers})"
    }
}

// FT Polygonal Prism (Shallow) generator
add_puzzle_generator(
    id = "ft_polygonal_prism",
    version = "1.0.1",
    name = "FT Polygonal Prism (Shallow)",
    params = [
        param_polygon_size("Polygon size"),
        param_polygon_width("Width"),
        param_line_height("Height"),
    ],
    engine = "euclid",
    gen = fn(n, width, height) {
        return #{
            name = ft_polygonal_prism_name(n, width, height, "Shallow"),
            aliases = [ft_polygonal_prism_long_name(n, width, height, "Shallow")],
            ndim = 3,
            colors = "polygonal_prism:${n}",
            twists = "ft_polygonal_prismatic:${n}",
            build = fn() {
                use sym, polygon, line from @shapes/product(#{
                    polygon = @shapes/i/polygon.new(n),
                    line = @shapes/line.new(),
                })
                h = polygon.edge_length / 2

                with #sym = sym {
                    // Carve shape
                    carve(plane(line.endpoint * h), line.names("U", "D"))
                    carve(plane(polygon.edge_pole), "F${polygon.edge_names}")

                    // Slice layers
                    add_layers(#twists.base_axis, @util/layers.inclusive(h, -h, height))
                    add_layers(#twists.side_axis, polygon.shallow_cut_depths(width))
                    if #twists.opposite_side_axis != null {
                        add_layers(#twists.opposite_side_axis, @util/layers.opposite_depths(polygon.shallow_cut_depths(width)))
                    }
                }
            },

            tags = #{
                type = "puzzle",
                "turns_by/3d/rank1" = n == 3,
                "algebraic/abelian" = width == 1,
                "algebraic/trivial" = width == 1 or (n == 4 and width == 2 and height == 1),
                "cuts/canonical" = width == 3 and height == 3,
                "cuts/depth/shallow" = width > 2 or height > 2,
                "cuts/depth/deep/to_adjacent" = height.is_even() or (width.is_even() and n > 3),
                "cuts/depth/half" = height.is_even() or (n <= 4 and width.is_even()),
                "cuts/depth/shallow" = width == 3 and height == 3,
                "pieces/sphenic" = width <= 3 and height == 1,
            },
        }
    },

    tags = #{
        schema = 1,
        stable = "2.0.0",
        author = ["Andrew Farkas", "Luna Harran"],
        shape = "3d/prism",
        axes = ["1d/axial", "2d/polygonal", "hybrid/prismatic"],
        turns_by = "3d/rank2",
        algebraic = ["doctrinaire", "pseudo/doctrinaire"],
    },
)

// FT Triminx Prism generator
add_puzzle_generator(
    id = "ft_triminx_prism",
    version = "1.0.1",
    name = "FT Triminx Prism",
    params = [
        param_polygon_width("Width"),
        param_line_height("Height"),
    ],
    engine = "euclid",
    gen = fn(width, height) {
        return #{
            name = ft_polygonal_prism_name(3, width, height, "Triminx"),
            aliases = [ft_polygonal_prism_long_name(3, width, height, "Triminx")],
            ndim = 3,
            colors = "polygonal_prism:3",
            twists = "ft_polygonal_prismatic:3",
            build = fn() {
                use sym, polygon, line from @shapes/product(#{
                    polygon = @shapes/i/polygon.new(3),
                    line = @shapes/line.new(),
                })
                h = polygon.edge_length / 2

                with #sym = sym {
                    // Carve shape
                    carve(plane(line.endpoint * h), line.names("U", "D"))
                    carve(plane(polygon.edge_pole), "F${polygon.edge_names}")

                    // Slice layers
                    add_layers(#twists.base_axis, @util/layers.inclusive(h, -h, height))
                    add_layers(#twists.side_axis, polygon.full_cut_depths(width))
                    if #twists.opposite_side_axis != null {
                        add_layers(#twists.opposite_side_axis, @util/layers.opposite_depths(polygon.full_cut_depths(width)))
                    }
                }
            },

            tags = #{
                type = "puzzle",
                "cuts/depth/shallow" = height == 3 or width >= 4,
                "cuts/depth/deep/to_adjacent" = height.is_even() or width.is_odd(),
                "cuts/depth/half" = height.is_even() or width.is_odd(),
                "algebraic/trivial" = width == 1 or (height == 1 and width == 2),
                "pieces/sphenic" = width == 2 and height >= 2,
            },
        }
    },

    tags = #{
        schema = 1,
        stable = "2.0.0",
        author = ["Andrew Farkas", "Luna Harran"],
        shape = "3d/prism",
        axes = ["1d/axial", "2d/polygonal", "hybrid/prismatic"],
        turns_by = ["3d/rank1", "3d/rank2"],
        algebraic = ["doctrinaire", "pseudo/doctrinaire"],
    },
)

// FT Polygonal Prism twist system generator
add_twist_system_generator(
    id = "ft_polygonal_prismatic",
    name = "FT Polygonal Prism",
    params = [param_polygon_size("Polygon Size")],
    engine = "euclid",
    ndim = 3,
    gen = fn(n) {
        return #{
            name = "FT ${@shapes/prisms/polygonal_prism.name(n)}",
            build = fn() {
                shape = @shapes/prisms/polygonal_prism.new(n)

                // Add axes and twists
                with #sym = shape.sym {
                    export base_axis = add_axis(shape.base_pole, shape.base_names)
                    export side_axis = add_axis(shape.side_pole, shape.side_names)
                    add_twist(base_axis, #sym.thru([1, 0]), gizmo_pole_distance = shape.h)
                    add_twist(side_axis, #sym.thru([2, 0]), gizmo_pole_distance = 1)

                    opposite_side_axis = null
                    if n == 3 {
                        opposite_side_axis = add_axis(
                            -shape.side_pole,
                            #sym.names(
                                point(shape.side_pole),
                                #{VA = [], VB = [0, 1, "VA"], VC = [0, 1, "VB"]}, // TODO: bikeshed names
                            ),
                        )
                        add_twist(opposite_side_axis, #sym.thru([0, 2]), gizmo_pole_distance = 1)
                    }
                    export opposite_side_axis
                }

                // Add global twist directions
                fn cw(axis) { #twists[axis.name] }
                fn ccw(axis) { #twists[axis.name].rev() }
                add_twist_direction("CW", fn(ax) { [cw(ax)] })
                add_twist_direction("CCW", fn(ax) { [ccw(ax)] })

                // Add vantage group
                add_vantage_group(
                    id = "polygonal_prism",
                    symmetry = shape.sym,
                    refs = [
                        [shape.base_pole, shape.base_names],
                        [shape.side_pole, shape.side_names],
                    ],
                    init = ["FA", "U"],
                )

                // Add side-centered vantage set
                F = side_axis
                U = base_axis
                y = shape.sym.thru([2, 0])
                z2 = shape.sym.thru([1, 0])
                add_vantage_set(
                    name = "Side-centered",
                    group = "polygonal_prism",
                    view_offset = rot(start = vec(x=1), end = vec(z=1), angle = 20°)
                                * rot(start = vec(y=1), end = vec(z=1), angle = 35°),
                    transforms = #{
                        y = y, "y'" = y.rev(),
                        z2 = z2, "z2'" = z2.rev(),
                    },
                    axes = #{
                        F = F,
                        R = #twists.U.transform(F),
                        L = #twists.U.rev().transform(F),
                        U = U,
                        D = #twists.FA.transform(U),
                    },
                )
            },
        }
    },
)

fn build_ft_polygonal_duoprism(shape: Map, a_depths: List[Num], b_depths: List[Num]) {
    with #sym = shape.sym {
        // Carve shape
        carve(plane(shape.a_facet_pole), shape.a_facet_names)
        carve(plane(shape.b_facet_pole), shape.b_facet_names)

        // Slice layers
        add_layers(#twists.a_axis, a_depths)
        add_layers(#twists.b_axis, b_depths)
        if #twists.z_axis != null {
            add_layers(#twists.z_axis, @util/layers.opposite_depths(a_depths))
        }
        if #twists.y_axis != null {
            add_layers(#twists.y_axis, @util/layers.opposite_depths(b_depths))
        }
    }
}

// FT Polygonal Duoprism (Shallow) generator
add_puzzle_generator(
    id = "ft_polygonal_duoprism",
    version = "1.0.1",
    name = "FT Polygonal Duoprism (Shallow)",
    params = @shapes/prisms/polygonal_duoprism.params ++ [
        param_polygon_width("Layers A"),
        param_polygon_width("Layers B"),
    ],
    engine = "euclid",
    ndim = 4,
    gen = fn(n, m, n_layers, m_layers) {
        if n_layers == 1 and m_layers == 1 {
            return "polygonal_duoprism:${n},${m}"
        }
        canonical_id = (if n > m or (n == m and n_layers > m_layers) { "${#id}:${n},${m},${n_layers},${m_layers}" } else { "${#id}:${m},${n},${m_layers},${n_layers}" })

        return #{
            name = ft_duoprism_name(n, m, n_layers, m_layers, "Shallow"),
            aliases = [ft_duoprism_long_name(m, n, m_layers, n_layers, "Shallow")],
            colors = "polygonal_duoprism:${n},${m}",
            twists = "ft_polygonal_duoprism:${n},${m}",
            build = fn() {
                shape = @shapes/prisms/polygonal_duoprism.new(n, m)
                a_depths = shape.a.shallow_cut_depths(n_layers)
                b_depths = shape.b.shallow_cut_depths(m_layers)
                build_ft_polygonal_duoprism(shape, a_depths, b_depths)
            },

            tags = #{
                type = "puzzle",
                "turns_by/4d/rank2" = n == 3 or m == 3,
                "cuts/canonical" = n_layers == 3 and m_layers == 3,
                "cuts/depth/shallow" = not (n == 4 and m == 4 and n_layers == 2 and m_layers == 2),
                "cuts/depth/deep/to_adjacent" = (n == 4 and n_layers.is_even()) or (m == 4 and m_layers.is_even()),
                "cuts/depth/half" = (n == 4 and n_layers.is_even()) or (m == 4 and m_layers.is_even()),
                "external/leaderboard" = n_layers >= 2 and m_layers >= 2,
                canonical_id = canonical_id,
                big = n > 50 or m > 50,
            },
        }
    },

    tags = #{
        schema = 1,
        stable = "2.0.0",
        author = ["Andrew Farkas", "Luna Harran"],
        shape = "4d/duoprism",
        axes = ["2d/polygonal", "hybrid/duoprismatic"],
        turns_by = ["4d/rank3"],
        algebraic = ["doctrinaire", "pseudo/doctrinaire"],
    },

    examples = [
        // All the ones in MC4D
        #{params = [3, 3, 3, 3]},
        // #{params = [4, 3, 3, 3]},
        #{params = [5, 4, 3, 3]},
        // #{params = [6, 4, 3, 3]},
        // #{params = [7, 4, 3, 3]},
        // #{params = [8, 4, 3, 3]},
        // #{params = [10, 4, 3, 3]},
        #{params = [5, 3, 3, 3]},
        #{params = [10, 5, 3, 3]},
        #{params = [5, 5, 3, 3]},
        // #{params = [6, 6, 3, 3]},
        // #{params = [7, 7, 3, 3]},
        // #{params = [8, 8, 3, 3]},
        // #{params = [9, 9, 3, 3]},
        // #{params = [10, 10, 3, 3]},
        #{params = [100, 4, 3, 3], tags = #{meme = true}},
    ],
)

// FT Polygonal Duoprism (Shallow, Triminx) generator
add_puzzle_generator(
    id = "ft_polygonal_duoprism_3_minx",
    version = "1.0.1",
    name = "FT Polygonal Duoprism (Shallow, Triminx)",
    params = [
        @shapes/prisms/polygonal_duoprism.params[0],
        param_polygon_width("Layers A"),
        param_polygon_width("Layers (3)"),
    ],
    engine = "euclid",
    ndim = 4,
    gen = fn(n, n_layers, m_layers) {
        return #{
            name = ft_duoprism_name(n, 3, n_layers, m_layers, "Shallow", "Triminx"),
            aliases = [ft_duoprism_long_name(3, n, m_layers, n_layers, "Triminx", "Shallow")],
            colors = "polygonal_duoprism:${n},3",
            twists = "ft_polygonal_duoprism:${n},3",
            build = fn() {
                shape = @shapes/prisms/polygonal_duoprism.new(n, 3)
                a_depths = shape.a.shallow_cut_depths(n_layers)
                b_depths = shape.b.full_cut_depths(m_layers)
                build_ft_polygonal_duoprism(shape, a_depths, b_depths)
            },

            tags = #{
                type = "puzzle",
                "cuts/depth/deep/to_adjacent" = (n == 4 and n_layers.is_even()) or m_layers.is_odd(),
                "cuts/depth/half" = (n == 4 and n_layers.is_even()) or m_layers.is_odd(),
                "external/leaderboard" = n_layers >= 2 and m_layers >= 2,
            },
        }
    },

    tags = #{
        schema = 1,
        stable = "2.0.0",
        author = ["Andrew Farkas", "Luna Harran"],
        shape = "4d/duoprism",
        axes = ["2d/polygonal", "hybrid/duoprismatic"],
        turns_by = ["4d/rank2", "4d/rank3"],
        algebraic = ["doctrinaire", "pseudo/doctrinaire"],
        cuts = ["depth/shallow"],
    },

    examples = [
        // All the ones in MC4D
        #{params = [3, 3, 3]},
        // #{params = [4, 3, 3]},
        #{params = [5, 3, 3]},
    ],
)

// FT Polygonal Duoprism (Triminx) generator
add_puzzle_generator(
    id = "ft_polygonal_duoprism_3_minx_3_minx",
    version = "1.0.1",
    name = "FT Polygonal Duoprism (Triminx)",
    params = [
        param_polygon_width("Layers A"),
        param_polygon_width("Layers B"),
    ],
    engine = "euclid",
    ndim = 4,
    gen = fn(n_layers, m_layers) {
        canonical_id = (if n_layers > m_layers { "${#id}:${n_layers},${m_layers}" } else { "${#id}:${m_layers},${n_layers}" })
        return #{
            name = ft_duoprism_name(3, 3, n_layers, m_layers, "Triminx"),
            aliases = [ft_duoprism_long_name(3, 3, m_layers, n_layers, "Triminx")],
            colors = "polygonal_duoprism:3,3",
            twists = "ft_polygonal_duoprism:3,3",
            build = fn() {
                shape = @shapes/prisms/polygonal_duoprism.new(3, 3)
                a_depths = shape.a.full_cut_depths(n_layers)
                b_depths = shape.b.full_cut_depths(m_layers)
                build_ft_polygonal_duoprism(shape, a_depths, b_depths)
            },

            tags = #{
                type = "puzzle",
                "cuts/depth/deep/to_adjacent" = n_layers.is_odd() or m_layers.is_odd(),
                "cuts/depth/half" = n_layers.is_odd() or m_layers.is_odd(),
                "external/leaderboard" = n_layers >= 2 and m_layers >= 2,
                canonical_id = canonical_id,
            },
        }
    },

    tags = #{
        schema = 1,
        stable = "2.0.0",
        author = ["Andrew Farkas", "Luna Harran"],
        shape = "4d/duoprism",
        axes = ["2d/polygonal", "hybrid/duoprismatic"],
        turns_by = ["4d/rank2", "4d/rank3"],
        algebraic = ["doctrinaire", "pseudo/doctrinaire"],
        cuts = ["depth/shallow"],
    },

    examples = [
        #{params = [3, 3]},
    ],
)

// FT Polygonal Duoprism twist system generator
add_twist_system_generator(
    id = "ft_polygonal_duoprism",
    name = "FT Polygonal Duoprism",
    params = [param_polygon_size("Polygon A"), param_polygon_size("Polygon B")],
    engine = "euclid",
    ndim = 4,
    gen = fn(n, m) {
        return #{
            name = "FT ${@shapes/prisms/polygonal_duoprism.name(n, m)}",
            build = fn() {
                shape = @shapes/prisms/polygonal_duoprism.new(n, m)

                // Gizmo pole distances
                gizmo_base_a = shape.a.edge_length / 2
                gizmo_base_b = shape.b.edge_length / 2
                gizmo_edge_a = lerp(shape.a.outradius, 1, FACET_GIZMO_EDGE_FACTOR)
                gizmo_edge_b = lerp(shape.b.outradius, 1, FACET_GIZMO_EDGE_FACTOR)

                // Add axes and twists
                with #sym = shape.sym {
                    export a_axis = add_axis(shape.a_facet_pole, shape.a_facet_names)
                    export b_axis = add_axis(shape.b_facet_pole, shape.b_facet_names)

                    a1 = a_axis
                    b1 = b_axis
                    a2 = #sym.thru([1, 0]).transform(a1)
                    b2 = #sym.thru([3, 2]).transform(b1)

                    // A twists
                    add_twist(a1, #sym.thru([2, 3]), name = "_${a2}", gizmo_pole_distance = gizmo_base_a)
                    add_twist(a1, #sym.thru([2, 0]), name = "_${b1}", gizmo_pole_distance = 1)
                    add_twist(a1, #sym.thru([0, 3]), name = "_{${b1}_${b2}}", gizmo_pole_distance = gizmo_edge_b)

                    // B twists
                    add_twist(b1, #sym.thru([0, 1]), name = "_${b2}", gizmo_pole_distance = gizmo_base_b)
                    add_twist(b1, #sym.thru([0, 2]), name = "_${a1}", gizmo_pole_distance = 1)
                    add_twist(b1, #sym.thru([2, 1]), name = "_{${a1}_${a2}}", gizmo_pole_distance = gizmo_edge_a)

                    if n == 3 {
                        export z_axis = add_axis(shape.a_facet_opposite_pole, shape.a_facet_opposite_names)
                        add_twist(z_axis, refl().transform(#sym.thru([3, 2])), name = "_${a2}", gizmo_pole_distance = RIDGE_GIZMO_FACTOR)
                        add_twist(z_axis, refl().transform(#sym.thru([0, 2])), name = "_${b1}", gizmo_pole_distance = 1)
                        add_twist(z_axis, refl().transform(#sym.thru([3, 0])), name = "_{${b1}_${b2}}", gizmo_pole_distance = gizmo_edge_b)
                    } else {
                        export z_axis = null
                    }
                    if m == 3 {
                        export y_axis = add_axis(shape.b_facet_opposite_pole, shape.b_facet_opposite_names)
                        add_twist(y_axis, refl().transform(#sym.thru([1, 0])), name = "_${b2}", gizmo_pole_distance = RIDGE_GIZMO_FACTOR)
                        add_twist(y_axis, refl().transform(#sym.thru([2, 0])), name = "_${a1}", gizmo_pole_distance = 1)
                        add_twist(y_axis, refl().transform(#sym.thru([1, 2])), name = "_{${a1}_${a2}}", gizmo_pole_distance = gizmo_edge_a)
                    } else {
                        export y_axis = null
                    }
                }

                // Add vantage group
                add_vantage_group(
                    id = "polygonal_duoprism",
                    symmetry = shape.sym,
                    refs = [
                        [shape.a_facet_pole, shape.a_facet_names],
                        [shape.b_facet_pole, shape.b_facet_names],
                    ],
                    init = ["εA", "εB", "ηA"],
                )

                // Add facet-centered XZ/YW vantage set
                use εA, εB, ηA, ηB from #axes
                xy = shape.sym.thru([1, 0])
                εZ = xy.rev().transform(εA)
                zw = shape.sym.thru([3, 2])
                ηZ = zw.rev().transform(ηA)

                add_vantage_set(
                    name = "Facet-centered XZ/YW",
                    group = "polygonal_duoprism",
                    view_offset = ident(), // TODO
                    transforms = #{ xy = xy, zw = zw }, // TODO: more
                    axes = #{
                        L = εZ, F = εA, R = εB,
                        D = ηZ, I = ηA, U = ηB,
                    },
                )
            },
        }
    },
)
