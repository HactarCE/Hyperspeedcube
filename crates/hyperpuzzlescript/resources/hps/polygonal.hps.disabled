import utils from lib

NGONAL_NAMES = [
    null,
    "Monogonal",
    "Digonal",
    "Triangular",
    "Square",
    "Pentagonal",
    "Hexagonal",
    "Heptagonal",
    "Octagonal",
    "Nonagonal",
    "Decagonal",
]


export fn ngonal_name(i: Num) -> Str { NGONAL_NAMES[i] ?? "${i}-gonal" }

fn face_names(n: Num) -> Str { face_names(n, 1, 0) }

fn face_names(n: Num, mirror2: Num, mirror1: Num) {
    names = #{}
    names[utils.nth_uppercase_name(1)] = []
    for i in 1..n {
        names[utils.nth_uppercase_name(i)] = [m2, m1, utils.nth_uppercase_name(i-1)]
    }
    return names
}

/// Length of an edge
export fn edge_length(n) { 2 * tan(pi / n) }

/// Length of an edge when projected perpendicular to an adjacent edge
export fn edge_depth(n) { sin(2 * pi / n) * edge_length(n) }

export fn outradius(n) { 1 / cos(pi / n) }

/// Constructs an N-gon with inradius `scale`
export fn ngon(n: Num) { ngon(n, 1, "xy") }
export fn ngon(n: Num, scale: Num) { ngon(n, scale, "xy") }
export fn ngon(n: Num, scale: Num, basis: Any) {
    export edge_length = edge_length(n) * scale
    export edge_depth = edge_depth(n) * scale
    export outradius = outradius(n) * scale
    export diameter = scale * if n % 2 == 0 { 2 } else { 1 + 1 / cos(pi / n) }

    export sym = cd([n], basis)

    export fn iter_face_poles() { sym.orbit(sym.ox.unit * scale) }
    export fn iter_vertices() { sym.orbit(sym.xo.unit * scale) }
    export fn face_names() { face_names(n, 1, 0) }
    export fn vertex_names() { face_names(n, 0, 1) }
    export fn shallow_cut_depths(layer_count: Num) {
        if n == 3 {
            cut_depths = utils.layers.even_odd(1, 0, layer_count)
            cut_depths.push(-2)
            return cut_depths
        } else {
            max_cut_depth = 1 - edge_depth / 2
            return utils.layers.even_odd(1, max_cut_depth, layer_count)
        }
    }
    export fn full_cut_depths(layer_count: Num) {
        utils.layers.inclusive(scale, max_cut_depth * scale, layer_count)
    }

    if n == 3 {
        export fn opposite_full_cut_depths(layer_count: Num) {
            utils.layers.inclusive(-max_cut_depth * scale, -scale, layer_count)
        }
    }
}
