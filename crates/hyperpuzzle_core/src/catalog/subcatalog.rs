use super::*;

/// List of all puzzles and puzzle generators in a catalog.
pub type PuzzleCatalog = SubCatalog<Puzzle>;

/// List of all color systems and color system generators in a catalog.
pub type ColorSystemCatalog = SubCatalog<ColorSystem>;

/// Subcatalog for a specific object type (puzzles, color systems, twist
/// systems, etc.).
#[derive(Debug)]
pub struct SubCatalog<T: CatalogObject> {
    /// Loaded object generators by ID.
    pub(super) loaded_generators: HashMap<String, Arc<T::SpecGenerator>>,
    /// Loaded objects specs by ID.
    pub(super) loaded_specs: HashMap<String, Arc<T::Spec>>,
    /// Cache of object specs generated by generators.
    ///
    /// Where `T::Spec = T`, this is exactly the same as `objects` but is
    /// necessary to avoid deadlocks with generators. It's not ideal.
    pub(super) generated_specs: HashMap<String, Arc<Mutex<CacheEntry<T::Spec>>>>,
    /// Cache of objects created from specifications (from `loaded_specs` or
    /// `generated_specs`).
    pub(super) objects: HashMap<String, Arc<Mutex<CacheEntry<T>>>>,

    /// Cached list of generator examples.
    generator_examples: Option<Arc<Vec<Arc<T::Spec>>>>,
    /// Cached list of all object specifications.
    all_specs: Option<Arc<Vec<Arc<T::Spec>>>>,
    /// Cached puzzle list entries.
    puzzle_list_entries: Option<Arc<Vec<Arc<PuzzleListMetadata>>>>,
}

impl<T: CatalogObject> Default for SubCatalog<T> {
    fn default() -> Self {
        Self {
            loaded_generators: HashMap::default(),
            loaded_specs: HashMap::default(),
            generated_specs: HashMap::default(),
            objects: HashMap::default(),

            generator_examples: None,
            all_specs: None,
            puzzle_list_entries: None,
        }
    }
}

impl<T: CatalogObject> SubCatalog<T> {
    pub(crate) fn add_spec(&mut self, spec: Arc<T::Spec>) -> eyre::Result<()> {
        let id = spec.id();
        crate::validate_id(id)?;
        self.loaded_specs.insert(id.to_owned(), spec);
        self.clear_cache();
        Ok(())
    }
    pub(crate) fn add_spec_generator(&mut self, spec: Arc<T::SpecGenerator>) -> eyre::Result<()> {
        let id = spec.id();
        crate::validate_id(id)?;
        self.loaded_generators.insert(id.to_owned(), spec);
        self.clear_cache();
        Ok(())
    }

    /// Returns loaded object generators by ID.
    pub fn loaded_generators(&self) -> &HashMap<String, Arc<T::SpecGenerator>> {
        &self.loaded_generators
    }
    /// Returns loaded objects specs by ID.
    pub fn loaded_specs(&self) -> &HashMap<String, Arc<T::Spec>> {
        &self.loaded_specs
    }

    /// Returns a list of generator examples.
    ///
    /// This is cached, so calling it repeatedly is cheap.
    pub fn generator_examples(&mut self) -> Arc<Vec<Arc<T::Spec>>> {
        Arc::clone(self.generator_examples.get_or_insert_with(|| {
            Arc::new(
                self.loaded_generators
                    .values()
                    .filter_map(|generator| T::get_generator_examples(generator))
                    .flat_map(|examples| examples.values())
                    .cloned()
                    .collect(),
            )
        }))
    }

    fn clear_cache(&mut self) {
        self.generator_examples = None;
        self.all_specs = None;
        self.puzzle_list_entries = None;
    }

    /// Returns a list of object specs, including examples for generators, in an
    /// unspecified order.
    ///
    /// This is cached, so calling it repeatedly is cheap.
    pub fn specs(&mut self) -> Arc<Vec<Arc<T::Spec>>> {
        let generator_examples = self.generator_examples();
        Arc::clone(self.all_specs.get_or_insert_with(|| {
            Arc::new(
                itertools::chain(self.loaded_specs.values(), &*generator_examples)
                    .cloned()
                    .collect(),
            )
        }))
    }
}

impl PuzzleCatalog {
    /// Returns all entries that might show in the puzzle list, in an
    /// unspecified order: non-generated puzzles, example puzzles, and puzzle
    /// generators.
    ///
    /// This is cached, so calling it repeatedly is cheap.
    pub fn puzzle_list_entries(&mut self) -> Arc<Vec<Arc<PuzzleListMetadata>>> {
        let specs = self.specs();
        Arc::clone(self.puzzle_list_entries.get_or_insert_with(|| {
            Arc::new(
                itertools::chain(
                    self.loaded_generators.values().map(|g| &g.meta),
                    specs.iter().map(|o| &o.meta),
                )
                .cloned()
                .collect(),
            )
        }))
    }
}
