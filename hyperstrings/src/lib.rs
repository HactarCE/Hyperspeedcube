#![allow(clippy::too_many_lines, clippy::unwrap_used)]
#![allow(missing_docs)]

use std::fmt;
use std::path::Path;

#[macro_use]
extern crate lazy_static;

use lang::Lang;
use owo_colors::OwoColorize;

mod lang;
mod schema;
mod util;
mod warn;

use schema::*;
use warn::*;

pub const CONFIG_FILE_NAME: &str = "config";

#[derive(Debug, Default)]
struct Langs {
    pub schema: Schema,
    pub langs: Vec<Lang>,
}
impl fmt::Display for Langs {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "//! Autogenerated locale module.")?;
        writeln!(f, "//!")?;
        writeln!(
            f,
            "//! DO NOT MODIFY THIS FILE DIRECTLY. Instead modify the KDL files.",
        )?;
        writeln!(f, "#![allow(unused_imports)]")?;
        writeln!(f)?;

        // List langs.
        writeln!(f, "#[rustfmt::skip]")?;
        writeln!(f, "#[allow(unused)]")?;
        writeln!(
            f,
            "const LANGS: &[(&str, structs::{LANG_STRUCT_NAME})] = &["
        )?;
        for lang in &self.langs {
            let lang_name = &lang.name;
            writeln!(f, "    ({lang_name:?}, {lang_name}::{LANG_CONST_NAME}),")?;
        }
        writeln!(f, "];")?;
        writeln!(f)?;

        // Write schema modules.
        writeln!(f, "{}", self.schema)?;
        writeln!(f)?;

        // Write lang modules.
        for lang in &self.langs {
            lang.display_module(f, &self.schema)?;
        }
        Ok(())
    }
}

pub fn generate_locale_source_code(locale_dir: impl AsRef<Path>, output_file: impl AsRef<Path>) {
    // Sanity-check file extension to ensure that we don't accidentally
    // overwrite a KDL file.
    assert_eq!(
        "rs",
        output_file.as_ref().extension().unwrap().to_string_lossy(),
        "expected `.rs` extension for output file"
    );

    let config_file_path = locale_dir
        .as_ref()
        .to_owned()
        .join(format!("{CONFIG_FILE_NAME}.kdl"));

    // Load config file
    let mut schema = Schema::init_from_config_file(&config_file_path);

    let Some(fallback_lang) = schema.fallback_lang.clone() else {
        warn("missing key `fallback`. example: `fallback \"en\"`");
        return;
    };
    schema.infer_from_lang_file(locale_dir.as_ref().join(fallback_lang + ".kdl"));
    let mut langs = Langs {
        schema,
        langs: vec![],
    };

    // Load locale files
    let locale_files = locale_dir.as_ref().read_dir().unwrap();

    for dir_entry in locale_files {
        let file_path = dir_entry.unwrap().path();
        if file_path == config_file_path {
            continue;
        }
        if !file_path.extension().is_some_and(|ext| ext == "kdl") {
            let file_path = file_path.to_string_lossy();
            warn(&format!("ignoring file {}", file_path.blue().bold()));
            continue;
        }
        langs
            .langs
            .push(Lang::from_file(file_path, &mut langs.schema));
    }

    langs.schema.finalize();

    std::fs::write(output_file, langs.to_string()).expect("error writing output");
}
