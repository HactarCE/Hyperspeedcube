#![allow(missing_docs)]

use std::fmt;
use std::path::Path;

use kdl::KdlDocument;
use lang::{parse_lang, Lang};
use owo_colors::OwoColorize;

mod lang;
mod schema;
mod util;
mod warn;

use schema::*;
use warn::*;

pub const CONFIG_FILE_NAME: &str = "config";

#[derive(Debug, Default)]
struct Langs {
    pub schema: Schema,
    pub langs: Vec<Lang>,
}
impl fmt::Display for Langs {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "/// Autogenerated locale module.")?;
        writeln!(f, "///")?;
        writeln!(
            f,
            "/// DO NOT MODIFY THIS FILE DIRECTLY. Instead modify the KDL files.",
        )?;
        writeln!(f, "")?;

        // List langs.
        writeln!(f, "#[rustfmt::skip]")?;
        writeln!(
            f,
            "const LANGS: &[(&'static str, structs::{LANG_STRUCT_TYPE})] = &["
        )?;
        for lang in &self.langs {
            let lang_name = &lang.name;
            writeln!(f, "    ({lang_name:?}, {lang_name}::{LANG_STRUCT_NAME}),")?;
        }
        writeln!(f, "];")?;
        writeln!(f)?;

        // Write schema modules.
        writeln!(f, "{}", self.schema)?;
        writeln!(f)?;

        // Write lang modules.
        for lang in &self.langs {
            lang.display_module(f, &self.schema)?;
        }
        Ok(())
    }
}

pub fn generate_locale_source_code(locale_dir: impl AsRef<Path>, output_file: impl AsRef<Path>) {
    // Sanity-check file extension to ensure that we don't accidentally
    // overwrite a KDL file.
    assert_eq!(
        "rs",
        output_file.as_ref().extension().unwrap().to_string_lossy(),
        "expected `.rs` extension for output file"
    );

    let config_file_path = locale_dir
        .as_ref()
        .to_owned()
        .join(format!("{CONFIG_FILE_NAME}.kdl"));

    // Load config file
    let mut langs = parse_config(&config_file_path);

    // Load locale files
    let locale_files = locale_dir.as_ref().read_dir().unwrap();

    for dir_entry in locale_files {
        let file_path = dir_entry.unwrap().path();
        if file_path == config_file_path {
            continue;
        }
        if !file_path.extension().is_some_and(|ext| ext == "kdl") {
            let file_path = file_path.to_string_lossy();
            warn(&format!("ignoring file {}", file_path.blue().bold()));
            continue;
        }
        langs.langs.push(parse_lang(file_path, &mut langs.schema))
    }

    std::fs::write(output_file, langs.to_string()).expect("error writing output");
}

fn read_kdl_file(path: impl AsRef<Path>) -> (SourceInfo, KdlDocument) {
    let src = SourceInfo {
        filename: path.as_ref().to_string_lossy().into_owned(),
        contents: std::fs::read_to_string(path).unwrap(),
    };
    match src.contents.parse() {
        Ok(kdl) => (src, kdl),
        Err(e) => {
            for line in e.to_string().lines() {
                warn(line);
            }
            panic!("bad KDL file");
        }
    }
}

fn parse_config(path: impl AsRef<Path>) -> Langs {
    let (src, doc) = read_kdl_file(path);

    let mut langs = Langs::default();

    for node in doc.nodes() {
        let node_loc = || src.at(node.span().offset());

        let mut entries = node.entries().iter();
        match node.name().value() {
            "fallback" => {
                // IIFE to mimic try_block
                let fallback_lang =
                    util::take_entry(&src, node, &mut entries, "expected fallback lang specifier")
                        .and_then(|entry| util::take_entry_string_value(&src, entry));
                if let Some(s) = fallback_lang {
                    util::warn_if_overwriting(
                        &mut langs.schema.fallback_lang,
                        s,
                        "duplicate `fallback` specification",
                        || src.at(node.span().offset()),
                    );
                }

                util::ignore_entries(&src, entries);
                util::ignore_children(&src, node);
            }

            "trait" => langs
                .schema
                .traits
                .extend(schema::parse_trait_schema(&src, node)),

            "struct" => langs
                .schema
                .structs
                .extend(schema::parse_struct_schema(&src, node)),

            k => warn_with("unknown node", node_loc(), k.red()),
        }
    }

    langs
}
