// /// Reference to an oriented shape in a [`Space`].
// #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
// pub struct ShapeRef {
//     /// Unoriented ID.
//     pub id: ShapeId,
//     /// Orientation.
//     pub sign: Sign,
//     /// Shape reference type.
//     pub ref_type: ShapeRefType,
// }
// impl fmt::Display for ShapeRef {
//     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
//         write!(f, "{}{}", self.sign, self.id)
//     }
// }
// impl ShapeRef {
//     pub fn pos(id: ShapeId, ref_type: ShapeRefType) -> Self {
//         Self {
//             id,
//             sign: Sign::Pos,
//             ref_type,
//         }
//     }
// }
// impl Fits64 for ShapeRef {
//     unsafe fn from_u64(x: u64) -> Self {
//         Self {
//             id: ShapeId::from_u64(x >> 2),
//             sign: if x & 1 == 0 { Sign::Pos } else { Sign::Neg },
//             ref_type: if x & 2 == 0 {
//                 ShapeRefType::Real
//             } else {
//                 ShapeRefType::Mirror
//             },
//         }
//     }

//     fn to_u64(self) -> u64 {
//         (self.id.to_u64() << 2) | ((self.ref_type as u64) << 1) | self.sign as u64
//     }
// }
// impl Neg for ShapeRef {
//     type Output = Self;

//     fn neg(mut self) -> Self::Output {
//         self.sign = -self.sign;
//         self
//     }
// }
// impl PartialOrd for ShapeRef {
//     fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
//         Some(self.cmp(other))
//     }
// }
// impl Ord for ShapeRef {
//     fn cmp(&self, other: &Self) -> Ordering {
//         self.to_u64().cmp(&other.to_u64())
//     }
// }
// hypermath::impl_mul_sign!(impl Mul<Sign> for ShapeRef);
// hypermath::impl_mulassign_sign!(impl MulAssign<Sign> for ShapeRef);

/// Whether a shape resulted from an intersection with a mirror plane.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ShapeRefType {
    /// Actual shape created by intersections of cuts.
    Real = 0,
    /// Intersection with at least one mirror plane. A shape with this manifold
    /// would not exist if not for the mirror planes.
    Mirror = 1,
}

/// Whether a shape is a mirror plane (or results from an intersection with one).
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ShapeClass {
    /// Actual shape created by intersections of cuts.
    Real,
    /// Intersection with at least one mirror plane. A shape with this manifold
    /// would not exist if not for the mirror planes.
    Mirror,
}
impl std::ops::BitOr for ShapeClass {
    type Output = Self;

    fn bitor(self, rhs: Self) -> Self::Output {
        // Always prioritize real cuts over mirror cuts.
        match (self, rhs) {
            (ShapeClass::Real, _) | (_, ShapeClass::Real) => ShapeClass::Real,
            (ShapeClass::Mirror, ShapeClass::Mirror) => ShapeClass::Mirror,
        }
    }
}
