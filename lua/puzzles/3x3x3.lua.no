shapes:add('cube', {
  -- symmetry = cd{4, 3},
  build = function(shape)
    for _, v in cd{4, 3}:cosets('oox') do
      shape:carve(v)
      shape.colors:add(v)
    end

    -- of course, helper functions will make this more ergonomic
    shape.colors[1].name = 'Right'
    shape.colors[1].default = 'red'
    shape.colors[2].name = 'Up'
    shape.colors[2].default = 'white'
    shape.colors:swap(1, 2)
  end,
})

axis_systems:add('cubic', {
  -- symmetry = cd{4, 3},
  build = function(axes)
    for _, v in cd{4, 3}:cosets('oox') do
      axes:add(v)
    end

    -- of course, helper functions will make this more ergonomic
    axes[1].name = 'R'
    axes[2].name = 'U'
    axes:swap(1, 2)
    rotations:add('x', {fix = axes.R, from = axes.F, to = axes.U})
    rotations:add('y', {fix = axes.U, from = axes.R, to = axes.F})
    rotations:add('z', {fix = axes.F, from = axes.U, to = axes.R})
  end,
})

-- facet-turning cubic
twist_systems:add('cubic.ft', {
  axes = 'cubic',
  build = function(twists)
    -- iterate over cosets of the group, where the elements within a coset all
    -- do the same thing to the 'oox' vector. `transform` is an arbitrary
    -- element from that coset.
    for transform in cd{4, 3}:cosets('oox') do
      local R = transform * twists.axes.R
      local U = transform * twists.axes.U
      local F = transform * twists.axes.F
      local xform = rot{plane = R.vector, from = F, to = U}
      twists:add(R,         {axis = R, transform = xform})
      twists:add(R .. "'",  {axis = R, transform = xform.inv})
      twists:add(R .. "2",  {axis = R, transform = xform * xform})
      twists:add(R .. "2'", {axis = R, transform = xform.inv * xform.inv})
    end

    twists.directions:add("CW", {twist = function(ax) return ax end})
    twists.directions:add("CCW", {twist = function(ax) return ax .. "'" end})
    twists.directions:add("180 CW", {twist = function(ax) return ax .. "2" end})
    twists.directions:add("180 CCW", {twist = function(ax) return ax .. "2'" end})
  end,
})

puzzles:add('3x3x3', {
  name = "3x3x3",
  aliases = {
    "{4, 3} 3",
    "3^3",
    "Rubik's Cube",
  },
  ndim = 3,
  meta = {
    id = '3x3x3',
    author = "Andrew Farkas",

    year = 1970,
    inventor = "Ern≈ë Rubik",

    family = "wca",
    external = {
      pcubes = "3x3x3",
      gelatinbrain = "3.1.2",
      museum = 2968,
    },
  },

  properties = {
    shallow_cut = true,
    doctrinaire = true,
  },

  shape = 'cube',
  twists = 'cubic.ft',

  build = function(p)
    for ax in iter(p.twists.axes) do
      local cut = plane{normal = ax.v, distance = 1/3}
      local opposite_cut = plane{normal = ax.v, distance = -1/3}
      p:slice(cut)
      ax.layers:add({boundary = cut})
      ax.layers:add({boundary = {-cut, opposite_cut}})
      ax.layers:add({boundary = {-opposite_cut}})
    end

    twists.aliases:add("M", {2, "L"})
    twists.aliases:add("E", {2, "D"})
    twists.aliases:add("S", {2, "F"})

    p.piece_types:add('corner')
    p.piece_types:add('edge')
    p.piece_types:add('center')

    local R = p.twists.axes.R
    local U = p.twists.axes.U
    local F = p.twists.axes.F

    -- find the set of pieces in R layer 1, U layer 1, and F layer 1
    local example_corner = R(1) & U(1) & F(1)
    -- take the closure of that set under the group symmetries
    local corners = cd{4, 3}:closure(example_corner)
    for _, piece in ipairs(corners) do
      piece.type = 'corner'
    end
    -- of course, helper functions will make this more ergonomic

    -- select only pieces that do not yet have a piece type
    local example_edge = (R(1) & U(1)):filter(function(piece) return piece.type == nil end)
    local edges = cd{4, 3}:closure(example_edge)
    for _, piece in ipairs(edges) do
      piece.type = 'edge'
    end

    local example_center = R(1):filter(function(piece) return piece.type == nil end)
    local centers = cd{4, 3}:closure(example_center)
    for _, piece in ipairs(centers) do
      piece.type = 'center'
    end

    -- alternatively
    for piece in p.pieces do
      piece.type = ({'center', 'edge', 'corner'})[#piece.stickers]
    end
  end,
})
