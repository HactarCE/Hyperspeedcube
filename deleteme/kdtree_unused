

pub fn insert(&mut self, key: K, value: V) -> Option<V> {
    match self.entry_mut(key) {
        Entry::Occupied(mut e) => Some(e.insert(value)),
        Entry::Vacant(e) => {
            e.insert(value);
            None
        }
    }
}



pub fn entry_mut(&mut self, key: K) -> Entry<'_, K, V> {
    let search_key = key;

    let mut node = &mut self.root;
    let mut center = self.center.clone();
    let mut radius = self.radius;

    loop {
        let new_bucket = search_key.bucket(&center);

        radius /= 2.0;
        center = Self::offset_center(center, &new_bucket, radius, search_key.min_axis_count());

        let new_entry = KdTreeEntry {
            bucket: new_bucket,
            contents: KdTreeNode::default(),
        };

        let bucket_index = match node.binary_search(&new_entry) {
            Ok(i) => node = &mut node[i].1,
            Err(i) => {
                node.insert(i, new_entry);
                node = &mut node[i].1;
            }
        }

        match node {
            KdTreeNode::Branch(entries) => match entries.binary_search(&new_entry) {
                Ok(i) => node = &mut entries[i].1,
                Err(i) => {
                    entries.insert(i, new_entry);
                    node = &mut entries[i].1;
                }
            },
            KdTreeNode::Leaf(leaf) => {
                if approx_eq(&leaf.key, &search_key) {
                    return node;
                }
                *node = KdTreeNode::Branch(vec![KdTreeEntry {
                    bucket: search_key.bucket(&center),
                    contents: *node,
                }]);
            }
        }
    }
}

fn entry(&self, key: &K) -> Option<&KdTreeLeaf<K, V>> {
    let search_key = key;

    let mut node = &self.root;
    let mut center = self.center.clone();
    let mut radius = self.radius;

    loop {
        match node {
            KdTreeNode::Leaf(leaf) => {
                return approx_eq(&leaf.key, search_key).then_some(leaf);
            }
            KdTreeNode::Branch(entries) => {
                let search_bucket = Self::get_bucket(&center, radius, &search_key);

                radius /= 2.0;
                center = Self::offset_center(
                    &search_bucket,
                    radius,
                    search_key.min_axis_count(),
                    center,
                );

                match entries.binary_search_by(|entry| entry.bucket.cmp(&search_bucket)) {
                    Ok(i) => node = &entries[i].contents,
                    Err(i) => return None,
                }
            }
        }
    }
}



pub enum Entry<'a, K, V> {
    Occupied(OccupiedEntry<'a, K, V>),
    Vacant(VacantEntry<'a, K, V>),
}




#[derive(Debug)]
pub struct OccupiedEntry<'a, K, V> {
    entry: &'a mut KdTreeLeaf<K, V>,
}
impl<'a, K, V> OccupiedEntry<'a, K, V> {
    pub fn get(&self) -> &'a V {
        &self.entry.value
    }
    pub fn insert(&mut self, value: V) -> V {
        std::mem::replace(&mut self.entry.value, value)
    }
}
#[derive(Debug)]
pub struct VacantEntry<'a, K, V> {
    node: &'a mut KdTreeNode<K, V>,
    node_center: K,

    index_to_insert: usize,
    bucket: Bucket,
    key: K,
}
impl<'a, K: KdTreeKey, V> VacantEntry<'a, K, V> {
    pub fn insert(self, value: V) -> &'a mut V {
        let new_entry = KdTreeEntry {
            bucket: self.bucket,
            contents: KdTreeNode::Leaf(KdTreeLeaf {
                key: self.key,
                value,
            }),
        };

        let entry_list;
        let index;
        match self.node {
            KdTreeNode::Branch(entries) => {
                entries.insert(self.index_to_insert, element);
            }
            KdTreeNode::Leaf(leaf) => {
                *self.node = KdTreeNode::Branch(vec![KdTreeEntry {
                    bucket: leaf.key.bucket(&self.node_center),
                    contents: leaf,
                }]);
                self.node.unwrap_branch_mut()
            }
        };
        entry_list[index].contents.unwrap_leaf()
    }
}

impl<K, V> KdTreeNode<K, V> {
    #[track_caller]
    fn unwrap_branch_mut(&mut self) -> &mut Vec<KdTreeEntry<K, V>> {
        match self {
            KdTreeNode::Leaf(branch) => branch,
            _ => panic!("expected branch node"),
        }
    }
    #[track_caller]
    fn unwrap_leaf_mut(&mut self) -> &mut KdTreeLeaf<K, V> {
        match self {
            KdTreeNode::Leaf(leaf) => leaf,
            _ => panic!("expected leaf node"),
        }
    }
}
